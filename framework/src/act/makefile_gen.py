##################################
# makefile_gen.py
#
# jcarlin@hmc.edu 6 Sept 2025
# SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1
#
# Generate Makefile for tests
##################################

import importlib.resources
from pathlib import Path
from typing import TypedDict

from act.config import Config
from act.parse_test_constraints import TestMetadata

# Makefile templates
MAKEFILE_HEADER = """
# This Makefile is auto-generated by cvw-arch-verif. Do not edit directly.
.DEFAULT_GOAL := compile
.PHONY: compile
"""


def gen_compile_targets(
    test_name: Path,
    test_metadata: TestMetadata,
    base_dir: Path,
    xlen: int,
    mabi: str,
    config: Config,
) -> str:
    # Define paths
    build_dir = base_dir / "build"
    elf_dir = base_dir / "elfs"
    sig_elf = build_dir / test_name.with_suffix(".sig.elf")
    sig_file = build_dir / test_name.with_suffix(".sig")
    result_file = build_dir / test_name.with_suffix(".results")
    sig_log_file = build_dir / test_name.with_suffix(".sig.log")
    final_elf = elf_dir / test_name.with_suffix(".elf")

    # Extract metadata
    march = test_metadata.march
    flen = test_metadata.flen
    test_path = test_metadata.test_path
    ref_model_sig_flags = config.ref_model_type.signature_flags.format(sig_file=sig_file, granularity=int(xlen / 8))

    # Generate Makefile targets
    return (
        f"########## Targets for {test_name} ##########\n"
        "# Generate signature based ELF\n"
        f"{sig_elf}: {test_path} | {sig_elf.parent}\n"
        f"\t{config.compiler_string} $(CFLAGS) \\\n"
        f"\t\t-o {sig_elf} \\\n"
        f"\t\t-march={march} -mabi={mabi} -DSIGNATURE -DXLEN={xlen} -DFLEN={flen} \\\n"
        f"\t\t{test_path}\n"
        f"\n"
        "# Generate signature file\n"
        f"{sig_file}: {sig_elf}\n"
        f"\t{config.ref_model_exe} \\\n"
        f"\t\t--config {config.dut_include_dir}/sail.json \\\n"  # TODO: don't hardcode sail config file
        f"\t\t{ref_model_sig_flags} \\\n"
        f"\t\t{sig_elf} \\\n"
        f"\t\t> {sig_log_file} 2>&1\n"
        f"\n"
        f"# Modify sig file for inclusion in assembly\n"
        f"{result_file}: {sig_file}\n"
        f"\tuv run sig_modify {sig_file} {xlen}\n"
        f"\n"
        "# Final ELF target\n"
        f"{final_elf}: {sig_elf} {result_file} | {final_elf.parent}\n"
        f"\t{config.compiler_string} $(CFLAGS) \\\n"
        f"\t\t-o {final_elf} \\\n"
        f"\t\t-march={march} -mabi={mabi} -DSELFCHECK -DXLEN={xlen} -DFLEN={flen} \\\n"
        f'\t\t-DSIGNATURE_FILE=\\"{result_file}\\" \\\n'
        f"\t\t{test_path}\n"
        # Objdump
        f"{
            f'\n\t{config.objdump_exe} -Stsxd -M no-aliases,numeric \\\n\t\t{final_elf} \\\n\t\t> {final_elf}.objdump\n'
            if config.objdump_exe is not None
            else '# skipping objdump generation\n'
        }"
    )


def gen_rvvi_targets(test_name: Path, base_dir: Path, config: Config) -> str:
    # Define paths
    coverage_dir = base_dir / "coverage"
    elf_dir = base_dir / "elfs"
    elf = elf_dir / test_name.with_suffix(".elf")
    sail_trace = coverage_dir / test_name.with_suffix(".trace")
    rvvi_trace = coverage_dir / test_name.with_suffix(".rvvi")

    # Generate Makefile targets
    return (
        "# Run test on Sail to generate log\n"
        f"{sail_trace}: {elf}\n"
        f"\t{config.ref_model_exe} --trace-all \\\n"
        f"\t\t--config {config.dut_include_dir}/sail.json \\\n"  # TODO: don't hardcode sail config file
        f"\t\t{elf} \\\n"
        f"\t\t--trace-output {sail_trace} \\\n"
        f"\t\t> {sail_trace}.log 2>&1\n"
        f"\n"
        "# Generate RVVI trace\n"
        f"{rvvi_trace}: {sail_trace}\n"
        f"\tuv run sail-to-rvvi \\\n"
        f"\t\t{sail_trace} \\\n"
        f"\t\t{rvvi_trace}\n"
    )


def write_makefile(
    makefile_path: Path,
    main_targets: list[tuple[str, list[Path], str]],
    directory_set: set[str],
    makefile_lines: list[str],
) -> None:
    """Write out a Makefile."""
    # Create top-level targets
    for variable_name, targets, command in main_targets:
        makefile_lines.append(f"{variable_name} = \\")
        makefile_lines.extend(f"\t{target} \\" for target in targets)
        makefile_lines.append(f"\n{command}: $({variable_name})\n")

    # Directory creation rules
    makefile_lines.extend([f"{' '.join(directory_set)}:", "\tmkdir -p $@", ""])

    # Write out Makefile
    makefile_path.parent.mkdir(parents=True, exist_ok=True)
    makefile_path.write_text("\n".join(makefile_lines))


def generate_common_makefile(
    config: Config,
    common_test_list: dict[str, TestMetadata],
    tests_dir: Path,
    wkdir: Path,
    xlen: int,
    mabi: str,
) -> None:
    """Generate a Makefile to compile the common tests."""
    # Define paths
    common_wkdir = wkdir / "common"
    common_elf_dir = common_wkdir / "elfs"
    common_build_dir = common_wkdir / "build"

    # Makefile targets
    directory_set: set[str] = set()
    test_targets: list[Path] = []
    makefile_lines = [
        MAKEFILE_HEADER,
        f"CFLAGS += -O0 -g -mcmodel=medany -nostartfiles -I{tests_dir}/env -I{tests_dir}/priv/headers",
        f"XLEN := {xlen}",
    ]

    # Build Makefile targets for each test
    for test_name, test_metadata in common_test_list.items():
        test_name = Path(test_name)
        elf_name = test_name.with_suffix(".elf")
        final_elf = common_elf_dir / elf_name
        test_targets.append(final_elf)
        directory_set.update([str((common_elf_dir / test_name).parent), str((common_build_dir / test_name).parent)])
        makefile_lines.append(gen_compile_targets(test_name, test_metadata, common_wkdir, xlen, mabi, config))

    # Write out Makefile
    makefile_path = common_wkdir / f"Makefile-rv{xlen}.mk"
    write_makefile(makefile_path, [("ELFS", test_targets, "compile")], directory_set, makefile_lines)


def generate_config_makefile(
    config: Config,
    config_test_list: dict[str, TestMetadata],
    common_test_list: dict[str, TestMetadata],
    tests_dir: Path,
    coverpoint_dir: Path,
    wkdir: Path,
    config_name: str,
    xlen: int,
    mabi: str,
    coverage_enabled: bool,
) -> None:
    """Generate a Makefile to compile the config-specific tests."""
    # Define paths
    config_wkdir = wkdir / config_name
    config_elf_dir = config_wkdir / "elfs"
    config_build_dir = config_wkdir / "build"
    config_coverage_dir = config_wkdir / "coverage"
    config_report_dir = config_wkdir / "reports"
    common_wkdir = wkdir / "common"
    common_elf_dir = common_wkdir / "elfs"

    # Makefile targets
    directory_set: set[str] = set()
    test_targets: list[Path] = []
    coverage_targets: dict[Path, list[Path]] = {}
    makefile_lines = [
        MAKEFILE_HEADER,
        f"CFLAGS += -O0 -g -mcmodel=medany -nostartfiles -I{tests_dir}/env -I{tests_dir}/priv/headers",
        f"XLEN := {xlen}",
    ]

    # Build Makefile targets for each test
    for test_name, test_metadata in config_test_list.items():
        # Test specific paths
        test_name = Path(test_name)
        elf_name = test_name.with_suffix(".elf")
        final_elf = config_elf_dir / elf_name
        trace_name = test_name.with_suffix(".rvvi")
        trace_path = config_coverage_dir / trace_name

        # Add test to target lists
        test_targets.append(final_elf)
        directory_set.update([str((config_elf_dir / test_name).parent), str((config_build_dir / test_name).parent)])

        # Generate compilation/symlink targets
        if str(test_name) in common_test_list:
            common_elf = common_elf_dir / elf_name
            makefile_lines.append(
                f"# Create symlink to common elf for {test_name}\n"
                f"{final_elf}: {common_elf} | {final_elf.parent}\n"
                f"\tln -sf {common_elf} \\\n"
                f"\t\t{final_elf}\n"
                f"\tln -sf {common_elf}.objdump \\\n"
                f"\t\t{final_elf}.objdump\n"
                if config.objdump_exe is not None
                else "# skipping objdump\n",
            )
        else:
            makefile_lines.append(gen_compile_targets(test_name, test_metadata, config_wkdir, xlen, mabi, config))

        # Generate coverage trace targets
        if coverage_enabled:
            if trace_path.parent not in coverage_targets:
                coverage_targets[trace_path.parent] = []
            coverage_targets[trace_path.parent].append(trace_path.absolute())
            makefile_lines.append(gen_rvvi_targets(test_name, config_wkdir, config))
            makefile_lines.append("\n")

    main_targets = [("ELFS", test_targets, "compile")]

    # Generate coverage targets
    if coverage_enabled:
        coverage_makefile_lines, coverage_reports = gen_coverage_targets(
            coverage_targets,
            coverpoint_dir,
            config_coverage_dir,
            config_report_dir,
            config.dut_include_dir,  # TODO: coverage config dir should be generated from UDB
        )
        makefile_lines.append(coverage_makefile_lines)
        main_targets.append(("COVERAGE_REPORTS", coverage_reports, "coverage"))

    # Write out Makefile
    makefile_path = config_wkdir / "Makefile"
    write_makefile(
        makefile_path,
        main_targets,
        directory_set,
        makefile_lines,
    )


def gen_coverage_targets(
    coverage_targets: dict[Path, list[Path]],
    coverpoint_dir: Path,
    base_dir: Path,
    config_report_dir: Path,
    dut_header_dir: Path,
) -> tuple[str, list[Path]]:
    """Generate coverage targets and tracelists."""
    # Generate tracelist file for each extension/test group and a target to generate the UCDB coverage file
    makefile_lines = ["#################### Coverage targets ####################\n"]
    coverage_reports: list[Path] = []
    for coverage_group, traces in coverage_targets.items():
        # Define paths
        base_name = base_dir / coverage_group / coverage_group.stem
        tracelist_file = base_name.with_suffix(".tracelist")
        ucdb_file = base_name.with_suffix(".ucdb")
        work_dir = base_name.parent / "ucdb_work"
        report_file_base = config_report_dir / coverage_group.stem
        report_file = Path(f"{report_file_base}_report.txt")

        # Write the tracefile
        tracelist_file.parent.mkdir(parents=True, exist_ok=True)
        tracelist_file.write_text(
            f"# Tests for coverage group: {coverage_group}\n"
            + "# Generated automatically by cvw-arch-verif\n"
            + "\n".join([str(trace) for trace in traces])
        )

        # Add UCDB file to the list
        with (
            importlib.resources.path("act", "fcov") as fcov_path,
            importlib.resources.path("act", "cvw-arch-verif.do") as vsim_do_path,
        ):
            makefile_lines.append(
                f"# Generate UCDB file for {coverage_group.stem}\n"
                f"{ucdb_file}: {' '.join([str(trace) for trace in traces])}\n"
                f'\tvsim -c -do "do {vsim_do_path.absolute()} \\\n'
                f"\t\t{tracelist_file}\\\n"
                f"\t\t{ucdb_file}\\\n"
                f"\t\t{work_dir}\\\n"
                f"\t\t{fcov_path.absolute()}\\\n"
                f"\t\t{coverpoint_dir}\\\n"
                f"\t\t{dut_header_dir}\\\n"
                f'\t\t{{{coverage_group.stem.upper()}_COVERAGE}}" > {ucdb_file}.log 2>&1\n'
            )

        # Generate coverage report
        coverage_reports.append(report_file)
        makefile_lines.append(
            f"# Generate coverage report for {coverage_group.stem}\n"
            f".PHONY: {coverage_group.stem}-report\n"
            f"{coverage_group.stem}-report: {report_file}\n"
            f"{report_file}: {ucdb_file}\n"
            f"\tuv run coverreport\\\n"
            f"\t\t{ucdb_file}\\\n"
            f"\t\t{report_file_base}\n"
        )
    return ("\n".join(makefile_lines), coverage_reports)


class ConfigData(TypedDict):
    """Type definition for configuration data dictionary."""

    config: Config
    xlen: int
    selected_tests: dict[str, TestMetadata]


def generate_makefiles(
    configs: list[ConfigData],
    rv32_common_tests: dict[str, TestMetadata],
    rv64_common_tests: dict[str, TestMetadata],
    tests_dir: Path,
    coverpoint_dir: Path,
    workdir: Path,
    coverage_enabled: bool,
) -> None:
    """Generate Makefiles for multiple configurations with shared common directories."""
    rv32_common_generated = False
    rv64_common_generated = False
    top_makefile_lines = [MAKEFILE_HEADER]
    compile_targets: list[str] = []
    coverage_targets: list[str] = []

    for config_data in configs:
        # Unpack config data
        config = config_data["config"]
        config_name = config.name
        xlen = config_data["xlen"]
        selected_tests = config_data["selected_tests"]

        # Extract config parameters
        mabi = f"{'i' if xlen == 32 else ''}lp{xlen}"
        common_tests = rv32_common_tests if xlen == 32 else rv64_common_tests

        # Update top-level Makefile
        compile_targets.append(f"{config_name}-compile")
        coverage_targets.append(f"{config_name}-coverage")
        top_makefile_lines.extend(
            [
                f"{config_name}-compile: common-rv{xlen}-compile",
                f"\t$(MAKE) -C {config_name} compile",
                "",
            ]
        )
        if coverage_enabled:
            top_makefile_lines.extend(
                [
                    f"{config_name}-coverage: {config_name}-compile",
                    f"\t$(MAKE) -C {config_name} coverage",
                    "",
                ]
            )

        # Generate config-specific Makefile
        generate_config_makefile(
            config,
            selected_tests,
            common_tests,
            tests_dir,
            coverpoint_dir,
            workdir,
            config_name,
            xlen,
            mabi,
            coverage_enabled,
        )

        # Generate architecture-specific common Makefiles using first config of each XLEN
        if (xlen == 32 and not rv32_common_generated) or (xlen == 64 and not rv64_common_generated):
            generate_common_makefile(config, common_tests, tests_dir, workdir, xlen, mabi)
            top_makefile_lines.extend(
                [
                    f"common-rv{xlen}-compile:",
                    f"\t$(MAKE) -f common/Makefile-rv{xlen}.mk compile",
                    "",
                ]
            )

    # Write top-level Makefile
    top_makefile_lines.append(f"compile: {' '.join(compile_targets)}")
    if coverage_enabled:
        top_makefile_lines.append(f"coverage: {' '.join(coverage_targets)}")
    top_makefile = workdir / "Makefile"
    top_makefile.write_text("\n".join(top_makefile_lines))
